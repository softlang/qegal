@prefix sl: <http://org.softlang.com/> .

// Transitive closure on node references.
(?a sl:references ?b) (?b sl:references ?c) -> (?a sl:references ?c).

// Building an environment for each node. This is needed when referenced nodes have to be passed into a builtin.
(?x sl:partOf sl:target) noValue(?x,sl:env) (?x sl:references ?r)  makeTemp(?env)
    -> (?x sl:env ?env) (?env rdf:rest rdf:nil) (?env rdf:first ?r).
(?x sl:partOf sl:target) (?x sl:env ?oldEnv) noValue(?list,rdf:rest,?oldEnv)
    (?x sl:references ?r) listNotContains(?oldEnv, ?r) makeTemp(?newEnv)
    -> (?x sl:env ?newEnv) (?newEnv rdf:rest ?oldEnv) (?newEnv rdf:first ?r).


// This env can now be passed in any builtin. //(?x sl:env ?newEnv) (?env rdf:rest ?oldEnv) (?env rdf:first ?r).




// ##### General note on jena rule inference language #####
// Node that this language misses disjunction causing enumerating the alternative in form of rules.

//[eq: (?x sl:env ?env1) (?x sl:env ?env2) notEqual(?env1,?env2) -> remove(1)]

//[xsdConformance: (?xml sl:elementOf sl:XML)(?xml sl:env ?env) (?xsd sl:elementOf sl:XML) listContains(?env,?xsd) xsdConformance(?xml,?xsd,?env) -> (?xml sl:conformsTo ?xsd)]